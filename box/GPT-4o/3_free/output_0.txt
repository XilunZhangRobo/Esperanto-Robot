To achieve the task of stacking three objects to form the highest possible height while ensuring geometric stability, we need to follow these steps:

1. **Determine the Sizes of the Objects**: Use the `get_size()` function to get the dimensions of each object.
2. **Select the Objects to Stack**: Choose the three objects with the highest combined height.
3. **Plan the Stacking Order**: Ensure the stacking order is stable. Typically, larger base objects provide better stability.
4. **Execute the Stacking**: Use the robotic arm to stack the objects in the planned order.

### Step-by-Step Plan

1. **Get the Sizes of All Objects**:
   - Use `get_size()` to get the dimensions of `cubeA`, `cubeB`, `cubeC`, `cubeD`, `BottleA`, and `BallA`.

2. **Select the Three Tallest Objects**:
   - Sort the objects based on their height and select the top three.

3. **Determine the Stacking Order**:
   - Ensure the base is stable. Typically, cubes are more stable than bottles and balls.

4. **Execute the Stacking**:
   - Move the robotic arm to grasp each object.
   - Place each object on top of the previous one carefully.

### Python Code

```python
import numpy as np

# Step 1: Get the sizes of all objects
cubeA_size = get_size('cubeA')
cubeB_size = get_size('cubeB')
cubeC_size = get_size('cubeC')
cubeD_size = get_size('cubeD')
BottleA_size = get_size('BottleA')
BallA_size = get_size('BallA')

# Create a list of objects with their heights
objects = [
    ('cubeA', cubeA_size[2]),
    ('cubeB', cubeB_size[2]),
    ('cubeC', cubeC_size[2]),
    ('cubeD', cubeD_size[2]),
    ('BottleA', BottleA_size[2]),
    ('BallA', BallA_size[2])
]

# Step 2: Select the three tallest objects
objects_sorted = sorted(objects, key=lambda x: x[1], reverse=True)
tallest_objects = objects_sorted[:3]

# Step 3: Determine the stacking order (ensure stability)
# For simplicity, assume cubes are more stable than bottles and balls
# Sort by stability: cubes > bottles > balls
tallest_objects_sorted = sorted(tallest_objects, key=lambda x: ('cube' in x[0], 'Bottle' in x[0], 'Ball' in x[0]), reverse=True)

# Step 4: Execute the stacking
for i, (obj_name, _) in enumerate(tallest_objects_sorted):
    open_gripper()
    
    # Get the graspable point of the object
    graspable_point = get_graspable_point(obj_name)
    
    # Move to the top of the object first
    move_to_position(np.array(graspable_point) + np.array([0, 0, 0.1]))  # Move slightly above the object
    
    # Move down to grasp the object
    move_to_position(graspable_point)
    
    close_gripper()
    
    # Move to the stacking position
    if i == 0:
        # Place the first object on the base
        stacking_position = np.array([0, 0, 0])
    else:
        # Place the next object on top of the previous one
        stacking_position = stacking_position + np.array([0, 0, tallest_objects_sorted[i-1][1]])
    
    move_to_position(stacking_position + np.array([0, 0, 0.1]))  # Move slightly above the stacking position
    move_to_position(stacking_position)
    
    open_gripper()

# The objects are now stacked in the desired order
```

### Explanation

1. **Get Sizes**: We retrieve the sizes of all available objects.
2. **Select Tallest Objects**: We sort the objects by height and select the top three.
3. **Determine Stacking Order**: We sort the selected objects to ensure stability, prioritizing cubes over bottles and balls.
4. **Execute Stacking**: We use the robotic arm to grasp and stack the objects in the determined order, ensuring to move slightly above each object before grasping or placing it to avoid collisions.

This code should achieve the task of stacking three objects with the highest possible height while maintaining geometric stability.